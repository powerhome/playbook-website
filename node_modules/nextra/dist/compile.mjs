var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/compile.ts
import { createProcessor } from "@mdx-js/mdx";
import remarkGfm from "remark-gfm";
import rehypePrettyCode from "rehype-pretty-code";
import { rehypeMdxTitle } from "rehype-mdx-title";

// src/mdx-plugins/static-image.js
var relative = /^\.{1,2}\//;
function visit(node, type, handler) {
  if (node.type === type) {
    handler(node);
  }
  if (node.children) {
    node.children.forEach((n) => visit(n, type, handler));
  }
}
function ASTNodeImport(name, from) {
  return {
    type: "mdxjsEsm",
    value: `import ${name} from "${from}"`,
    data: {
      estree: {
        type: "Program",
        body: [
          {
            type: "ImportDeclaration",
            specifiers: [
              {
                type: "ImportDefaultSpecifier",
                local: { type: "Identifier", name }
              }
            ],
            source: {
              type: "Literal",
              value: from,
              raw: `"${from}"`
            }
          }
        ],
        sourceType: "module"
      }
    }
  };
}
function remarkStaticImage() {
  return (tree, _file, done) => {
    const importsToInject = [];
    visit(tree, "image", visitor);
    tree.children.unshift(...importsToInject);
    tree.children.unshift(ASTNodeImport("$NextImageNextra", "next/image"));
    done();
    function visitor(node) {
      const url = node.url;
      if (url && relative.test(url)) {
        const tempVariableName = `$nextraImage${importsToInject.length}`;
        Object.assign(node, {
          type: "mdxJsxFlowElement",
          name: "$NextImageNextra",
          attributes: [
            {
              type: "mdxJsxAttribute",
              name: "alt",
              value: node.alt || ""
            },
            {
              type: "mdxJsxAttribute",
              name: "placeholder",
              value: "blur"
            },
            {
              type: "mdxJsxAttribute",
              name: "src",
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: tempVariableName,
                data: {
                  estree: {
                    type: "Program",
                    body: [
                      {
                        type: "ExpressionStatement",
                        expression: {
                          type: "Identifier",
                          name: tempVariableName
                        }
                      }
                    ],
                    sourceType: "module"
                  }
                }
              }
            }
          ],
          children: []
        });
        importsToInject.push(ASTNodeImport(tempVariableName, url));
      }
    }
  };
}

// src/mdx-plugins/remark.ts
function visit2(node, tester, handler) {
  var _a;
  if (tester(node)) {
    handler(node);
  }
  (_a = node.children) == null ? void 0 : _a.forEach((n) => visit2(n, tester, handler));
}
function getFlattenedValue(node) {
  return node.children.map((child) => "children" in child ? getFlattenedValue(child) : "value" in child ? child.value : "").join("");
}
function remarkHeadings() {
  const data = this.data();
  return (tree, _file, done) => {
    visit2(tree, (node) => {
      return node.type === "heading" || node.name === "summary" || node.name === "details";
    }, (node) => {
      if (node.type === "heading") {
        const hasJsxInH1 = node.depth === 1 && Array.isArray(node.children) && node.children.some((child) => child.type === "mdxJsxTextElement");
        const heading = __spreadProps(__spreadValues({}, node), {
          value: getFlattenedValue(node)
        });
        data.headingMeta.headings.push(heading);
        if (hasJsxInH1) {
          data.headingMeta.hasJsxInH1 = true;
        }
      } else if (node.name === "summary" || node.name === "details") {
        if (node.data) {
          delete node.data._mdxExplicitJsx;
        }
      }
    });
    done();
  };
}

// src/mdx-plugins/structurize.js
import Slugger from "github-slugger";
function cleanup(content) {
  return content.trim().split("\n").map((line) => line.trim()).join("\n");
}
var structurize_default = (structurizedData, options) => {
  if (typeof options === "boolean")
    options = {};
  options = Object.assign({ codeblocks: true }, options);
  const slugger = new Slugger();
  let activeSlug = "";
  let skip = false;
  let content = "";
  return function stripMarkdown() {
    return (node) => {
      walk(node);
      structurizedData[activeSlug] = cleanup(content);
      return node;
    };
    function walk(node) {
      let result = "";
      const type = node.type;
      if (type === "heading")
        skip = true;
      if (["code", "table", "blockquote", "list", "mdxJsxFlowElement"].includes(type)) {
        result += "\n";
        if (!skip)
          content += "\n";
      }
      if ("children" in node) {
        for (let i = 0; i < node.children.length; i++) {
          result += walk(node.children[i]);
        }
      } else if ([
        options.codeblocks ? "code" : "",
        "text",
        "inlineCode",
        "tableCell"
      ].includes(type)) {
        result += node.value;
        if (!skip)
          content += node.value;
      }
      if ([
        "code",
        "table",
        "blockquote",
        "list",
        "listItem",
        "break",
        "mdxJsxFlowElement"
      ].includes(type)) {
        result += "\n";
        if (!skip)
          content += "\n";
      }
      if (["tableCell"].includes(type)) {
        result += "	";
        if (!skip)
          content += "	";
      }
      if (type === "heading")
        skip = false;
      if (type === "heading" && node.depth > 1) {
        structurizedData[activeSlug] = cleanup(content);
        content = "";
        activeSlug = slugger.slug(result) + "#" + result;
      }
      return result;
    }
  };
};

// src/mdx-plugins/rehype-handler.js
import Slugger2 from "github-slugger";
function visit3(node, tagNames, handler) {
  var _a;
  if (tagNames.includes(node.tagName)) {
    handler(node);
    return;
  }
  (_a = node.children) == null ? void 0 : _a.forEach((n) => visit3(n, tagNames, handler));
}
function parseMeta() {
  return (tree) => {
    visit3(tree, ["pre"], (node) => {
      var _a, _b, _c;
      if (Array.isArray(node.children) && node.children.length === 1 && node.children[0].tagName === "code" && typeof node.children[0].properties === "object") {
        const meta = (_b = (_a = node.children[0].data) == null ? void 0 : _a.meta) != null ? _b : node.children[0].properties.metastring;
        if (meta) {
          const filename = (_c = meta.match(/filename="([^"]+)"/)) == null ? void 0 : _c[1];
          if (filename) {
            node.__nextra_filename__ = filename;
          }
        }
      }
    });
  };
}
function attachMeta() {
  return (tree) => {
    const slugger = new Slugger2();
    visit3(tree, ["div", "h2", "h3", "h4", "h5", "h6"], (node) => {
      var _a;
      if (node.tagName === "div") {
        if (!("data-rehype-pretty-code-fragment" in node.properties))
          return;
        node.properties["data-nextra-code"] = "";
        if ("__nextra_filename__" in node) {
          node.properties["data-filename"] = node.__nextra_filename__;
        }
      } else {
        (_a = node.properties).id || (_a.id = slugger.slug(getFlattenedValue(node)));
      }
    });
  };
}

// src/theme.json
var theme_default = {
  name: "css-variables",
  type: "light",
  colors: {
    "editor.foreground": "#000001",
    "editor.background": "#000002"
  },
  tokenColors: [
    {
      settings: {
        foreground: "#000001"
      }
    },
    {
      scope: [
        "markup.deleted",
        "meta.diff.header.from-file",
        "punctuation.definition.deleted"
      ],
      settings: {
        foreground: "#ef6270"
      }
    },
    {
      scope: [
        "markup.inserted",
        "meta.diff.header.to-file",
        "punctuation.definition.inserted"
      ],
      settings: {
        foreground: "#4bb74a"
      }
    },
    {
      scope: [
        "keyword.operator.accessor",
        "meta.group.braces.round.function.arguments",
        "meta.template.expression",
        "markup.fenced_code meta.embedded.block"
      ],
      settings: {
        foreground: "#000001"
      }
    },
    {
      scope: "emphasis",
      settings: {
        fontStyle: "italic"
      }
    },
    {
      scope: ["strong", "markup.heading.markdown", "markup.bold.markdown"],
      settings: {
        fontStyle: "bold"
      }
    },
    {
      scope: ["markup.italic.markdown"],
      settings: {
        fontStyle: "italic"
      }
    },
    {
      scope: "meta.link.inline.markdown",
      settings: {
        fontStyle: "underline",
        foreground: "#000004"
      }
    },
    {
      scope: ["string", "markup.fenced_code", "markup.inline"],
      settings: {
        foreground: "#000005"
      }
    },
    {
      scope: ["comment", "string.quoted.docstring.multi"],
      settings: {
        foreground: "#000006"
      }
    },
    {
      scope: [
        "constant.numeric",
        "constant.language",
        "constant.other.placeholder",
        "constant.character.format.placeholder",
        "variable.language.this",
        "variable.other.object",
        "variable.other.class",
        "variable.other.constant",
        "meta.property-name",
        "meta.property-value",
        "support"
      ],
      settings: {
        foreground: "#000004"
      }
    },
    {
      scope: [
        "keyword",
        "storage.modifier",
        "storage.type",
        "storage.control.clojure",
        "entity.name.function.clojure",
        "entity.name.tag.yaml",
        "support.function.node",
        "support.type.property-name.json",
        "punctuation.separator.key-value",
        "punctuation.definition.template-expression"
      ],
      settings: {
        foreground: "#000007"
      }
    },
    {
      scope: "variable.parameter.function",
      settings: {
        foreground: "#000008"
      }
    },
    {
      scope: [
        "support.function",
        "entity.name.type",
        "entity.other.inherited-class",
        "meta.function-call",
        "meta.instance.constructor",
        "entity.other.attribute-name",
        "entity.name.function",
        "constant.keyword.clojure"
      ],
      settings: {
        foreground: "#000009"
      }
    },
    {
      scope: [
        "entity.name.tag",
        "string.quoted",
        "string.regexp",
        "string.interpolated",
        "string.template",
        "string.unquoted.plain.out.yaml",
        "keyword.other.template"
      ],
      settings: {
        foreground: "#000010"
      }
    },
    {
      scope: [
        "punctuation.definition.arguments",
        "punctuation.definition.dict",
        "punctuation.separator",
        "meta.function-call.arguments"
      ],
      settings: {
        foreground: "#000011"
      }
    },
    {
      name: "[Custom] Markdown links",
      scope: [
        "markup.underline.link",
        "punctuation.definition.metadata.markdown"
      ],
      settings: {
        foreground: "#000012"
      }
    },
    {
      name: "[Custom] Markdown list",
      scope: ["beginning.punctuation.definition.list.markdown"],
      settings: {
        foreground: "#000005"
      }
    },
    {
      name: "[Custom] Markdown punctuation definition brackets",
      scope: [
        "punctuation.definition.string.begin.markdown",
        "punctuation.definition.string.end.markdown",
        "string.other.link.title.markdown",
        "string.other.link.description.markdown"
      ],
      settings: {
        foreground: "#000007"
      }
    }
  ]
};

// src/compile.ts
var createCompiler = (mdxOptions) => {
  const compiler = createProcessor(mdxOptions);
  compiler.data("headingMeta", {
    headings: []
  });
  return compiler;
};
var rehypePrettyCodeOptions = {
  theme: theme_default,
  onVisitLine(node) {
    if (node.children.length === 0) {
      node.children = [{ type: "text", value: " " }];
    }
  },
  onVisitHighlightedLine(node) {
    node.properties.className.push("highlighted");
  },
  onVisitHighlightedWord(node) {
    node.properties.className = ["highlighted"];
  }
};
function compileMdx(_0) {
  return __async(this, arguments, function* (source, mdxOptions = {}, nextraOptions = {}, resourcePath = "") {
    var _a;
    const structurizedData = {};
    const compiler = createCompiler({
      jsx: (_a = mdxOptions.jsx) != null ? _a : true,
      outputFormat: mdxOptions.outputFormat,
      providerImportSource: "@mdx-js/react",
      remarkPlugins: [
        ...mdxOptions.remarkPlugins || [],
        remarkGfm,
        remarkHeadings,
        ...nextraOptions.unstable_staticImage ? [remarkStaticImage] : [],
        ...nextraOptions.unstable_flexsearch ? [structurize_default(structurizedData, nextraOptions.unstable_flexsearch)] : []
      ].filter(Boolean),
      rehypePlugins: [
        ...mdxOptions.rehypePlugins || [],
        parseMeta,
        [
          rehypePrettyCode,
          __spreadValues(__spreadValues({}, rehypePrettyCodeOptions), mdxOptions.rehypePrettyCodeOptions)
        ],
        [rehypeMdxTitle, { name: "titleText" }],
        attachMeta
      ].filter(Boolean)
    });
    try {
      const result = String(yield compiler.process(source)).replace("export const titleText =", "const titleText =").replace("export default MDXContent;", "");
      return __spreadProps(__spreadValues({
        result
      }, compiler.data("headingMeta")), {
        structurizedData
      });
    } catch (err) {
      console.error(`[nextra] Error compiling ${resourcePath}.`);
      throw err;
    }
  });
}
export {
  compileMdx
};
