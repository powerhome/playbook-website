"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/plugin.ts
var import_graceful_fs2 = __toESM(require("graceful-fs"));
var import_util = require("util");

// src/utils.ts
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));

// src/constants.ts
var MARKDOWN_EXTENSION_REGEX = /\.mdx?$/;
var IS_PRODUCTION = process.env.NODE_ENV === "production";
var LOCALE_REGEX = /\.([a-z]{2}(-[A-Z]{2})?)$/;
var DEFAULT_LOCALE = "en-US";

// src/utils.ts
function parseFileName(filePath) {
  var _a;
  const { name, ext } = import_path.default.parse(filePath);
  const locale = ((_a = name.match(LOCALE_REGEX)) == null ? void 0 : _a[1]) || "";
  return {
    name: locale ? name.replace(LOCALE_REGEX, "") : name,
    locale,
    ext
  };
}
var parseJsonFile = (content, path5) => {
  try {
    return JSON.parse(content);
  } catch (err) {
    console.error(`[nextra] Error parsing ${path5}, make sure it's a valid JSON`, err);
    return {};
  }
};
var existsSync = (filePath) => {
  try {
    import_fs.default.accessSync(filePath, import_fs.default.constants.F_OK);
    return true;
  } catch (e) {
    return false;
  }
};

// src/plugin.ts
var import_path4 = __toESM(require("path"));
var import_slash = __toESM(require("slash"));
var import_gray_matter = __toESM(require("gray-matter"));

// src/page-map.ts
var import_path2 = __toESM(require("path"));
function findPagesDir(dir = process.cwd()) {
  if (existsSync(import_path2.default.join(dir, "pages")))
    return "pages";
  if (existsSync(import_path2.default.join(dir, "src/pages")))
    return "src/pages";
  throw new Error("> Couldn't find a `pages` directory. Please create one under the project root");
}

// src/content-dump.ts
var import_graceful_fs = __toESM(require("graceful-fs"));
var import_path3 = __toESM(require("path"));
var { statSync, mkdirSync } = import_graceful_fs.default;
var cacheDir = import_path3.default.join(process.cwd(), ".next", "cache");
var assetDir = import_path3.default.join(process.cwd(), ".next", "static", "chunks");
try {
  statSync(assetDir);
} catch (e) {
  mkdirSync(assetDir, { recursive: true });
}
var cacheDirExist = false;
try {
  statSync(cacheDir);
  cacheDirExist = true;
} catch (e) {
  mkdirSync(cacheDir, { recursive: true });
}
function restoreCache() {
  return __async(this, null, function* () {
    if (cacheDirExist) {
      try {
        statSync(assetDir);
      } catch (e) {
        mkdirSync(assetDir, { recursive: true });
      }
      const files = import_graceful_fs.default.readdirSync(cacheDir);
      for (const file of files) {
        if (file.startsWith("nextra-data-")) {
          import_graceful_fs.default.copyFileSync(import_path3.default.join(cacheDir, file), import_path3.default.join(assetDir, file));
        }
      }
    }
  });
}

// src/plugin.ts
var readdir = (0, import_util.promisify)(import_graceful_fs2.default.readdir);
var readFile = (0, import_util.promisify)(import_graceful_fs2.default.readFile);
var collectMdx = (filePath, route = "") => __async(void 0, null, function* () {
  const { name, locale } = parseFileName(filePath);
  const content = yield readFile(filePath, "utf8");
  const { data } = (0, import_gray_matter.default)(content);
  return __spreadValues({
    name,
    route,
    locale
  }, Object.keys(data).length && { frontMatter: data });
});
function collectFiles(_0) {
  return __async(this, arguments, function* (dir, route = "/", fileMap = {}) {
    const files = yield readdir(dir, { withFileTypes: true });
    const items = (yield Promise.all(files.map((f) => __async(this, null, function* () {
      const filePath = import_path4.default.resolve(dir, f.name);
      const { name, locale, ext } = parseFileName(filePath);
      const fileRoute = (0, import_slash.default)(import_path4.default.join(route, name.replace(/^index$/, "")));
      if (f.isDirectory()) {
        if (fileRoute === "/api")
          return;
        const { items: items2 } = yield collectFiles(filePath, fileRoute, fileMap);
        if (!items2.length)
          return;
        return {
          name: f.name,
          children: items2,
          route: fileRoute
        };
      }
      if (MARKDOWN_EXTENSION_REGEX.test(ext)) {
        fileMap[filePath] = yield collectMdx(filePath, fileRoute);
        return fileMap[filePath];
      }
      if (ext === ".json" && name === "meta") {
        const content = yield readFile(filePath, "utf8");
        fileMap[filePath] = {
          name: "meta.json",
          locale,
          meta: parseJsonFile(content, filePath)
        };
        return fileMap[filePath];
      }
    })))).filter(Boolean);
    return {
      items,
      fileMap
    };
  });
}
var PageMapCache = class {
  constructor() {
    this.cache = { items: [], fileMap: {} };
  }
  set(data) {
    this.cache.items = data.items;
    this.cache.fileMap = data.fileMap;
  }
  clear() {
    this.cache = null;
  }
  get() {
    return this.cache;
  }
};
var pageMapCache = new PageMapCache();
var NextraPlugin = class {
  constructor(config) {
    this.config = config;
  }
  apply(compiler) {
    compiler.hooks.beforeCompile.tapAsync("NextraPlugin", (_, callback) => __async(this, null, function* () {
      var _a;
      if ((_a = this.config) == null ? void 0 : _a.unstable_flexsearch) {
        restoreCache();
      }
      const result = yield collectFiles(import_path4.default.join(process.cwd(), findPagesDir()), "/");
      pageMapCache.set(result);
      callback();
    }));
  }
};

// src/index.js
var DEFAULT_EXTENSIONS = ["js", "jsx", "ts", "tsx"];
var MARKDOWN_EXTENSIONS = ["md", "mdx"];
var nextra = (...config) => function withNextra(nextConfig = {}) {
  var _a, _b, _c;
  const nextraConfig = typeof config[0] === "string" ? {
    theme: config[0],
    themeConfig: config[1]
  } : config[0];
  const nextraPlugin = new NextraPlugin(nextraConfig);
  const { pageExtensions = DEFAULT_EXTENSIONS } = nextConfig;
  if ((_a = nextConfig.i18n) == null ? void 0 : _a.locales) {
    console.log("[nextra] You have Next.js i18n enabled, read here https://nextjs.org/docs/advanced-features/i18n-routing for the docs.");
  }
  const i18n = {
    locales: ((_b = nextConfig.i18n) == null ? void 0 : _b.locales) || [DEFAULT_LOCALE],
    defaultLocale: ((_c = nextConfig.i18n) == null ? void 0 : _c.defaultLocale) || DEFAULT_LOCALE
  };
  return __spreadProps(__spreadValues({}, nextConfig), {
    i18n,
    pageExtensions: [...pageExtensions, ...MARKDOWN_EXTENSIONS],
    webpack(config2, options) {
      var _a2;
      config2.plugins || (config2.plugins = []);
      config2.plugins.push(nextraPlugin);
      const nextraLoaderOptions = __spreadProps(__spreadValues({}, nextraConfig), {
        locales: i18n.locales,
        defaultLocale: i18n.defaultLocale,
        pageMapCache,
        newNextLinkBehavior: (_a2 = nextConfig.experimental) == null ? void 0 : _a2.newNextLinkBehavior
      });
      config2.module.rules.push({
        test: MARKDOWN_EXTENSION_REGEX,
        issuer: (request) => !!request,
        use: [
          options.defaultLoaders.babel,
          {
            loader: "nextra/loader",
            options: nextraLoaderOptions
          }
        ]
      }, {
        test: MARKDOWN_EXTENSION_REGEX,
        issuer: (request) => !request,
        use: [
          options.defaultLoaders.babel,
          {
            loader: "nextra/loader",
            options: __spreadProps(__spreadValues({}, nextraLoaderOptions), {
              pageImport: true
            })
          }
        ]
      });
      if (typeof nextConfig.webpack === "function") {
        return nextConfig.webpack(config2, options);
      }
      return config2;
    }
  });
};
module.exports = nextra;
