var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/loader.ts
import path5 from "path";
import grayMatter2 from "gray-matter";
import slash2 from "slash";
import { Repository } from "@napi-rs/simple-git";

// src/content-dump.ts
import fs from "graceful-fs";
import path from "path";
var { statSync, mkdirSync } = fs;
var cacheDir = path.join(process.cwd(), ".next", "cache");
var assetDir = path.join(process.cwd(), ".next", "static", "chunks");
var asset = {};
var cached = /* @__PURE__ */ new Map();
try {
  statSync(assetDir);
} catch (e) {
  mkdirSync(assetDir, { recursive: true });
}
var cacheDirExist = false;
try {
  statSync(cacheDir);
  cacheDirExist = true;
} catch (e) {
  mkdirSync(cacheDir, { recursive: true });
}
function initFromCache(filename) {
  if (!cached.has(filename)) {
    try {
      const content = fs.readFileSync(path.join(assetDir, filename), "utf8");
      cached.set(filename, true);
      return JSON.parse(content);
    } catch (e) {
      cached.set(filename, false);
    }
  }
  return {};
}
function addPage({
  fileLocale,
  route,
  title,
  meta,
  structurizedData
}) {
  const dataFilename = `nextra-data-${fileLocale}.json`;
  asset[fileLocale] || (asset[fileLocale] = initFromCache(dataFilename));
  asset[fileLocale][route] = {
    title: title || meta.title,
    data: structurizedData
  };
  const content = JSON.stringify(asset[fileLocale]);
  fs.writeFileSync(path.join(assetDir, dataFilename), content);
  fs.writeFileSync(path.join(cacheDir, dataFilename), content);
}

// src/utils.ts
import fs2 from "fs";
import path2 from "path";

// src/constants.ts
var MARKDOWN_EXTENSION_REGEX = /\.mdx?$/;
var IS_PRODUCTION = process.env.NODE_ENV === "production";
var LOCALE_REGEX = /\.([a-z]{2}(-[A-Z]{2})?)$/;
var DEFAULT_LOCALE = "en-US";
var OFFICIAL_THEMES = ["nextra-theme-docs", "nextra-theme-blog"];

// src/utils.ts
function parseFileName(filePath) {
  var _a;
  const { name, ext } = path2.parse(filePath);
  const locale = ((_a = name.match(LOCALE_REGEX)) == null ? void 0 : _a[1]) || "";
  return {
    name: locale ? name.replace(LOCALE_REGEX, "") : name,
    locale,
    ext
  };
}
var parseJsonFile = (content, path6) => {
  try {
    return JSON.parse(content);
  } catch (err) {
    console.error(`[nextra] Error parsing ${path6}, make sure it's a valid JSON`, err);
    return {};
  }
};
var existsSync = (filePath) => {
  try {
    fs2.accessSync(filePath, fs2.constants.F_OK);
    return true;
  } catch (e) {
    return false;
  }
};

// src/compile.ts
import { createProcessor } from "@mdx-js/mdx";
import remarkGfm from "remark-gfm";
import rehypePrettyCode from "rehype-pretty-code";
import { rehypeMdxTitle } from "rehype-mdx-title";

// src/mdx-plugins/static-image.js
var relative = /^\.{1,2}\//;
function visit(node, type, handler) {
  if (node.type === type) {
    handler(node);
  }
  if (node.children) {
    node.children.forEach((n) => visit(n, type, handler));
  }
}
function ASTNodeImport(name, from) {
  return {
    type: "mdxjsEsm",
    value: `import ${name} from "${from}"`,
    data: {
      estree: {
        type: "Program",
        body: [
          {
            type: "ImportDeclaration",
            specifiers: [
              {
                type: "ImportDefaultSpecifier",
                local: { type: "Identifier", name }
              }
            ],
            source: {
              type: "Literal",
              value: from,
              raw: `"${from}"`
            }
          }
        ],
        sourceType: "module"
      }
    }
  };
}
function remarkStaticImage() {
  return (tree, _file, done) => {
    const importsToInject = [];
    visit(tree, "image", visitor);
    tree.children.unshift(...importsToInject);
    tree.children.unshift(ASTNodeImport("$NextImageNextra", "next/image"));
    done();
    function visitor(node) {
      const url = node.url;
      if (url && relative.test(url)) {
        const tempVariableName = `$nextraImage${importsToInject.length}`;
        Object.assign(node, {
          type: "mdxJsxFlowElement",
          name: "$NextImageNextra",
          attributes: [
            {
              type: "mdxJsxAttribute",
              name: "alt",
              value: node.alt || ""
            },
            {
              type: "mdxJsxAttribute",
              name: "placeholder",
              value: "blur"
            },
            {
              type: "mdxJsxAttribute",
              name: "src",
              value: {
                type: "mdxJsxAttributeValueExpression",
                value: tempVariableName,
                data: {
                  estree: {
                    type: "Program",
                    body: [
                      {
                        type: "ExpressionStatement",
                        expression: {
                          type: "Identifier",
                          name: tempVariableName
                        }
                      }
                    ],
                    sourceType: "module"
                  }
                }
              }
            }
          ],
          children: []
        });
        importsToInject.push(ASTNodeImport(tempVariableName, url));
      }
    }
  };
}

// src/mdx-plugins/remark.ts
function visit2(node, tester, handler) {
  var _a;
  if (tester(node)) {
    handler(node);
  }
  (_a = node.children) == null ? void 0 : _a.forEach((n) => visit2(n, tester, handler));
}
function getFlattenedValue(node) {
  return node.children.map((child) => "children" in child ? getFlattenedValue(child) : "value" in child ? child.value : "").join("");
}
function remarkHeadings() {
  const data = this.data();
  return (tree, _file, done) => {
    visit2(tree, (node) => {
      return node.type === "heading" || node.name === "summary" || node.name === "details";
    }, (node) => {
      if (node.type === "heading") {
        const hasJsxInH1 = node.depth === 1 && Array.isArray(node.children) && node.children.some((child) => child.type === "mdxJsxTextElement");
        const heading = __spreadProps(__spreadValues({}, node), {
          value: getFlattenedValue(node)
        });
        data.headingMeta.headings.push(heading);
        if (hasJsxInH1) {
          data.headingMeta.hasJsxInH1 = true;
        }
      } else if (node.name === "summary" || node.name === "details") {
        if (node.data) {
          delete node.data._mdxExplicitJsx;
        }
      }
    });
    done();
  };
}

// src/mdx-plugins/structurize.js
import Slugger from "github-slugger";
function cleanup(content) {
  return content.trim().split("\n").map((line) => line.trim()).join("\n");
}
var structurize_default = (structurizedData, options) => {
  if (typeof options === "boolean")
    options = {};
  options = Object.assign({ codeblocks: true }, options);
  const slugger = new Slugger();
  let activeSlug = "";
  let skip = false;
  let content = "";
  return function stripMarkdown() {
    return (node) => {
      walk(node);
      structurizedData[activeSlug] = cleanup(content);
      return node;
    };
    function walk(node) {
      let result = "";
      const type = node.type;
      if (type === "heading")
        skip = true;
      if (["code", "table", "blockquote", "list", "mdxJsxFlowElement"].includes(type)) {
        result += "\n";
        if (!skip)
          content += "\n";
      }
      if ("children" in node) {
        for (let i = 0; i < node.children.length; i++) {
          result += walk(node.children[i]);
        }
      } else if ([
        options.codeblocks ? "code" : "",
        "text",
        "inlineCode",
        "tableCell"
      ].includes(type)) {
        result += node.value;
        if (!skip)
          content += node.value;
      }
      if ([
        "code",
        "table",
        "blockquote",
        "list",
        "listItem",
        "break",
        "mdxJsxFlowElement"
      ].includes(type)) {
        result += "\n";
        if (!skip)
          content += "\n";
      }
      if (["tableCell"].includes(type)) {
        result += "	";
        if (!skip)
          content += "	";
      }
      if (type === "heading")
        skip = false;
      if (type === "heading" && node.depth > 1) {
        structurizedData[activeSlug] = cleanup(content);
        content = "";
        activeSlug = slugger.slug(result) + "#" + result;
      }
      return result;
    }
  };
};

// src/mdx-plugins/rehype-handler.js
import Slugger2 from "github-slugger";
function visit3(node, tagNames, handler) {
  var _a;
  if (tagNames.includes(node.tagName)) {
    handler(node);
    return;
  }
  (_a = node.children) == null ? void 0 : _a.forEach((n) => visit3(n, tagNames, handler));
}
function parseMeta() {
  return (tree) => {
    visit3(tree, ["pre"], (node) => {
      var _a, _b, _c;
      if (Array.isArray(node.children) && node.children.length === 1 && node.children[0].tagName === "code" && typeof node.children[0].properties === "object") {
        const meta = (_b = (_a = node.children[0].data) == null ? void 0 : _a.meta) != null ? _b : node.children[0].properties.metastring;
        if (meta) {
          const filename = (_c = meta.match(/filename="([^"]+)"/)) == null ? void 0 : _c[1];
          if (filename) {
            node.__nextra_filename__ = filename;
          }
        }
      }
    });
  };
}
function attachMeta() {
  return (tree) => {
    const slugger = new Slugger2();
    visit3(tree, ["div", "h2", "h3", "h4", "h5", "h6"], (node) => {
      var _a;
      if (node.tagName === "div") {
        if (!("data-rehype-pretty-code-fragment" in node.properties))
          return;
        node.properties["data-nextra-code"] = "";
        if ("__nextra_filename__" in node) {
          node.properties["data-filename"] = node.__nextra_filename__;
        }
      } else {
        (_a = node.properties).id || (_a.id = slugger.slug(getFlattenedValue(node)));
      }
    });
  };
}

// src/theme.json
var theme_default = {
  name: "css-variables",
  type: "light",
  colors: {
    "editor.foreground": "#000001",
    "editor.background": "#000002"
  },
  tokenColors: [
    {
      settings: {
        foreground: "#000001"
      }
    },
    {
      scope: [
        "markup.deleted",
        "meta.diff.header.from-file",
        "punctuation.definition.deleted"
      ],
      settings: {
        foreground: "#ef6270"
      }
    },
    {
      scope: [
        "markup.inserted",
        "meta.diff.header.to-file",
        "punctuation.definition.inserted"
      ],
      settings: {
        foreground: "#4bb74a"
      }
    },
    {
      scope: [
        "keyword.operator.accessor",
        "meta.group.braces.round.function.arguments",
        "meta.template.expression",
        "markup.fenced_code meta.embedded.block"
      ],
      settings: {
        foreground: "#000001"
      }
    },
    {
      scope: "emphasis",
      settings: {
        fontStyle: "italic"
      }
    },
    {
      scope: ["strong", "markup.heading.markdown", "markup.bold.markdown"],
      settings: {
        fontStyle: "bold"
      }
    },
    {
      scope: ["markup.italic.markdown"],
      settings: {
        fontStyle: "italic"
      }
    },
    {
      scope: "meta.link.inline.markdown",
      settings: {
        fontStyle: "underline",
        foreground: "#000004"
      }
    },
    {
      scope: ["string", "markup.fenced_code", "markup.inline"],
      settings: {
        foreground: "#000005"
      }
    },
    {
      scope: ["comment", "string.quoted.docstring.multi"],
      settings: {
        foreground: "#000006"
      }
    },
    {
      scope: [
        "constant.numeric",
        "constant.language",
        "constant.other.placeholder",
        "constant.character.format.placeholder",
        "variable.language.this",
        "variable.other.object",
        "variable.other.class",
        "variable.other.constant",
        "meta.property-name",
        "meta.property-value",
        "support"
      ],
      settings: {
        foreground: "#000004"
      }
    },
    {
      scope: [
        "keyword",
        "storage.modifier",
        "storage.type",
        "storage.control.clojure",
        "entity.name.function.clojure",
        "entity.name.tag.yaml",
        "support.function.node",
        "support.type.property-name.json",
        "punctuation.separator.key-value",
        "punctuation.definition.template-expression"
      ],
      settings: {
        foreground: "#000007"
      }
    },
    {
      scope: "variable.parameter.function",
      settings: {
        foreground: "#000008"
      }
    },
    {
      scope: [
        "support.function",
        "entity.name.type",
        "entity.other.inherited-class",
        "meta.function-call",
        "meta.instance.constructor",
        "entity.other.attribute-name",
        "entity.name.function",
        "constant.keyword.clojure"
      ],
      settings: {
        foreground: "#000009"
      }
    },
    {
      scope: [
        "entity.name.tag",
        "string.quoted",
        "string.regexp",
        "string.interpolated",
        "string.template",
        "string.unquoted.plain.out.yaml",
        "keyword.other.template"
      ],
      settings: {
        foreground: "#000010"
      }
    },
    {
      scope: [
        "punctuation.definition.arguments",
        "punctuation.definition.dict",
        "punctuation.separator",
        "meta.function-call.arguments"
      ],
      settings: {
        foreground: "#000011"
      }
    },
    {
      name: "[Custom] Markdown links",
      scope: [
        "markup.underline.link",
        "punctuation.definition.metadata.markdown"
      ],
      settings: {
        foreground: "#000012"
      }
    },
    {
      name: "[Custom] Markdown list",
      scope: ["beginning.punctuation.definition.list.markdown"],
      settings: {
        foreground: "#000005"
      }
    },
    {
      name: "[Custom] Markdown punctuation definition brackets",
      scope: [
        "punctuation.definition.string.begin.markdown",
        "punctuation.definition.string.end.markdown",
        "string.other.link.title.markdown",
        "string.other.link.description.markdown"
      ],
      settings: {
        foreground: "#000007"
      }
    }
  ]
};

// src/compile.ts
var createCompiler = (mdxOptions) => {
  const compiler = createProcessor(mdxOptions);
  compiler.data("headingMeta", {
    headings: []
  });
  return compiler;
};
var rehypePrettyCodeOptions = {
  theme: theme_default,
  onVisitLine(node) {
    if (node.children.length === 0) {
      node.children = [{ type: "text", value: " " }];
    }
  },
  onVisitHighlightedLine(node) {
    node.properties.className.push("highlighted");
  },
  onVisitHighlightedWord(node) {
    node.properties.className = ["highlighted"];
  }
};
function compileMdx(_0) {
  return __async(this, arguments, function* (source, mdxOptions = {}, nextraOptions = {}, resourcePath = "") {
    var _a;
    const structurizedData = {};
    const compiler = createCompiler({
      jsx: (_a = mdxOptions.jsx) != null ? _a : true,
      outputFormat: mdxOptions.outputFormat,
      providerImportSource: "@mdx-js/react",
      remarkPlugins: [
        ...mdxOptions.remarkPlugins || [],
        remarkGfm,
        remarkHeadings,
        ...nextraOptions.unstable_staticImage ? [remarkStaticImage] : [],
        ...nextraOptions.unstable_flexsearch ? [structurize_default(structurizedData, nextraOptions.unstable_flexsearch)] : []
      ].filter(Boolean),
      rehypePlugins: [
        ...mdxOptions.rehypePlugins || [],
        parseMeta,
        [
          rehypePrettyCode,
          __spreadValues(__spreadValues({}, rehypePrettyCodeOptions), mdxOptions.rehypePrettyCodeOptions)
        ],
        [rehypeMdxTitle, { name: "titleText" }],
        attachMeta
      ].filter(Boolean)
    });
    try {
      const result = String(yield compiler.process(source)).replace("export const titleText =", "const titleText =").replace("export default MDXContent;", "");
      return __spreadProps(__spreadValues({
        result
      }, compiler.data("headingMeta")), {
        structurizedData
      });
    } catch (err) {
      console.error(`[nextra] Error compiling ${resourcePath}.`);
      throw err;
    }
  });
}

// src/page-map.ts
import path3 from "path";

// src/filter-route-locale.ts
function filterRouteLocale(pageMap, locale, defaultLocale) {
  const isDefaultLocale = !locale || locale === defaultLocale;
  const filteredPageMap = [];
  const fallbackPages = {};
  for (const page of pageMap) {
    if (page.children) {
      filteredPageMap.push(__spreadProps(__spreadValues({}, page), {
        children: filterRouteLocale(page.children, locale, defaultLocale)
      }));
      continue;
    }
    const localDoesMatch = !page.locale && isDefaultLocale || page.locale === locale;
    if (localDoesMatch) {
      fallbackPages[page.name] = null;
      filteredPageMap.push(page);
    } else {
      if (fallbackPages[page.name] !== null && (!page.locale || page.locale === defaultLocale)) {
        fallbackPages[page.name] = page;
      }
    }
  }
  for (const name in fallbackPages) {
    if (fallbackPages[name]) {
      filteredPageMap.push(fallbackPages[name]);
    }
  }
  return filteredPageMap;
}

// src/page-map.ts
function findPagesDir(dir = process.cwd()) {
  if (existsSync(path3.join(dir, "pages")))
    return "pages";
  if (existsSync(path3.join(dir, "src/pages")))
    return "src/pages";
  throw new Error("> Couldn't find a `pages` directory. Please create one under the project root");
}
function getPageMap(currentResourcePath, pageMap, fileMap, defaultLocale) {
  var _a, _b;
  const activeRouteLocale = parseFileName(currentResourcePath).locale;
  const pageItem = fileMap[currentResourcePath];
  const metaPath = path3.dirname(currentResourcePath);
  const metaExtension = activeRouteLocale ? `${activeRouteLocale}.json` : `json`;
  const pageMeta = (_b = (_a = fileMap[`${metaPath}/meta.${metaExtension}`]) == null ? void 0 : _a.meta) == null ? void 0 : _b[pageItem.name];
  const title = (typeof pageMeta === "string" ? pageMeta : pageMeta == null ? void 0 : pageMeta.title) || pageItem.name;
  return [
    activeRouteLocale ? filterRouteLocale(pageMap, activeRouteLocale, defaultLocale) : pageMap,
    pageItem.route,
    title
  ];
}

// src/plugin.ts
import fs3 from "graceful-fs";
import { promisify } from "util";
import path4 from "path";
import slash from "slash";
import grayMatter from "gray-matter";
var readdir = promisify(fs3.readdir);
var readFile = promisify(fs3.readFile);
var collectMdx = (filePath, route = "") => __async(void 0, null, function* () {
  const { name, locale } = parseFileName(filePath);
  const content = yield readFile(filePath, "utf8");
  const { data } = grayMatter(content);
  return __spreadValues({
    name,
    route,
    locale
  }, Object.keys(data).length && { frontMatter: data });
});
function collectFiles(_0) {
  return __async(this, arguments, function* (dir, route = "/", fileMap = {}) {
    const files = yield readdir(dir, { withFileTypes: true });
    const items = (yield Promise.all(files.map((f) => __async(this, null, function* () {
      const filePath = path4.resolve(dir, f.name);
      const { name, locale, ext } = parseFileName(filePath);
      const fileRoute = slash(path4.join(route, name.replace(/^index$/, "")));
      if (f.isDirectory()) {
        if (fileRoute === "/api")
          return;
        const { items: items2 } = yield collectFiles(filePath, fileRoute, fileMap);
        if (!items2.length)
          return;
        return {
          name: f.name,
          children: items2,
          route: fileRoute
        };
      }
      if (MARKDOWN_EXTENSION_REGEX.test(ext)) {
        fileMap[filePath] = yield collectMdx(filePath, fileRoute);
        return fileMap[filePath];
      }
      if (ext === ".json" && name === "meta") {
        const content = yield readFile(filePath, "utf8");
        fileMap[filePath] = {
          name: "meta.json",
          locale,
          meta: parseJsonFile(content, filePath)
        };
        return fileMap[filePath];
      }
    })))).filter(Boolean);
    return {
      items,
      fileMap
    };
  });
}
var PageMapCache = class {
  constructor() {
    this.cache = { items: [], fileMap: {} };
  }
  set(data) {
    this.cache.items = data.items;
    this.cache.fileMap = data.fileMap;
  }
  clear() {
    this.cache = null;
  }
  get() {
    return this.cache;
  }
};
var pageMapCache = new PageMapCache();

// src/loader.ts
var indexContentEmitted = /* @__PURE__ */ new Set();
var pagesDir = path5.resolve(findPagesDir());
var [repository, gitRoot] = function() {
  try {
    const repo = Repository.discover(process.cwd());
    if (repo.isShallow()) {
      if (process.env.VERCEL) {
        console.warn("[nextra] The repository is shallow cloned, so the latest modified time will not be presented. Set the VERCEL_DEEP_CLONE=true environment variable to enable deep cloning.");
      } else if (process.env.GITHUB_ACTION) {
        console.warn("[nextra] The repository is shallow cloned, so the latest modified time will not be presented. See https://github.com/actions/checkout#fetch-all-history-for-all-tags-and-branches to fetch all the history.");
      } else {
        console.warn("[nextra] The repository is shallow cloned, so the latest modified time will not be presented.");
      }
    }
    const gitRoot2 = path5.join(repo.path(), "..");
    return [repo, gitRoot2];
  } catch (e) {
    console.warn("[nextra] Init git repository failed", e);
    return [];
  }
}();
function loader(context, source) {
  return __async(this, null, function* () {
    const { resourcePath } = context;
    let {
      pageImport,
      theme,
      themeConfig,
      defaultLocale,
      unstable_flexsearch,
      unstable_staticImage,
      mdxOptions,
      pageMapCache: pageMapCache2,
      newNextLinkBehavior
    } = context.getOptions();
    context.cacheable(true);
    if (!theme) {
      throw new Error("No Nextra theme found!");
    }
    const themeIncludeStyles = OFFICIAL_THEMES.includes(theme);
    if (resourcePath.includes("/pages/api/")) {
      console.warn(`[nextra] Ignoring ${resourcePath} because it is located in the "pages/api" folder.`);
      return "";
    }
    const { items: pageMapResult, fileMap } = IS_PRODUCTION ? pageMapCache2.get() : yield collectFiles(pagesDir, "/");
    if (!fileMap[resourcePath]) {
      fileMap[resourcePath] = yield collectMdx(resourcePath);
      context.addMissingDependency(resourcePath);
    }
    const filename = path5.basename(resourcePath);
    const fileLocale = parseFileName(filename).locale;
    for (const [filePath, { name, locale }] of Object.entries(fileMap)) {
      if (name === "meta.json" && (!fileLocale || locale === fileLocale)) {
        context.addDependency(filePath);
      }
    }
    context.addContextDependency(pagesDir);
    const { data: meta, content } = grayMatter2(source);
    const { result, headings, structurizedData, hasJsxInH1 } = yield compileMdx(content, mdxOptions, {
      unstable_staticImage,
      unstable_flexsearch
    }, resourcePath);
    if (!pageImport) {
      return `
${themeIncludeStyles ? `import '${theme}/style.css'` : ""}
${result}
export default MDXContent`.trimStart();
    }
    const [pageMap, route, title] = getPageMap(resourcePath, pageMapResult, fileMap, defaultLocale);
    const skipFlexsearchIndexing = IS_PRODUCTION && indexContentEmitted.has(filename);
    if (unstable_flexsearch && !skipFlexsearchIndexing) {
      if (meta.searchable !== false) {
        addPage({
          fileLocale: fileLocale || DEFAULT_LOCALE,
          route,
          title,
          meta,
          structurizedData
        });
      }
      indexContentEmitted.add(filename);
    }
    let timestamp;
    if (repository && gitRoot) {
      try {
        timestamp = yield repository.getFileLatestModifiedDateAsync(path5.relative(gitRoot, resourcePath));
      } catch (e) {
      }
    }
    const layout = theme.startsWith(".") || theme.startsWith("/") ? path5.resolve(theme) : theme;
    const layoutConfig = themeConfig ? slash2(path5.resolve(themeConfig)) : "";
    const pageOpts = {
      filename: slash2(filename),
      route: slash2(route),
      meta,
      pageMap,
      headings,
      hasJsxInH1,
      timestamp,
      unstable_flexsearch,
      newNextLinkBehavior
    };
    const pageNextRoute = "/" + path5.relative(pagesDir, resourcePath).replace(MARKDOWN_EXTENSION_REGEX, "").replace(/\/index$/, "").replace(/^index$/, "");
    return `
import { SSGContext as __nextra_SSGContext__ } from 'nextra/ssg'

import __nextra_withLayout__ from '${layout}'
${themeIncludeStyles ? `import '${layout}/style.css'` : ""}
${layoutConfig ? `import __nextra_layoutConfig__ from '${layoutConfig}'` : ""}

${result}

const __nextra_pageOpts__ = ${JSON.stringify(pageOpts)}

globalThis.__nextra_internal__ = {
  pageMap: __nextra_pageOpts__.pageMap,
  route: __nextra_pageOpts__.route,
}

function Content(props) {
  return (
    <__nextra_SSGContext__.Provider value={props}>
      <MDXContent />
    </__nextra_SSGContext__.Provider>
  )
}

export default __nextra_withLayout__(
  ${JSON.stringify(pageNextRoute)},
  Content,
  {
    titleText: typeof titleText === 'string' ? titleText : undefined,
    ...__nextra_pageOpts__
  },
  ${layoutConfig ? "__nextra_layoutConfig__" : "null"},
)`.trimStart();
  });
}
function syncLoader(source, callback) {
  loader(this, source).then((result) => callback(null, result)).catch((err) => callback(err));
}
export {
  syncLoader as default
};
